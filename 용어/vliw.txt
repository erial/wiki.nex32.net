====== VLIW (Very Long Instruction word) ======
[{{  :용어:vliw:vliw_pipeline.jpg?320|크루소의 VLIW의 명령어 형태}}]
VLIW(Very Long Instruction Word)는 명령어를 여러개 처리 할 수 있는 방식으로, 동시에 여러 명령어를 실행할 수 있도록 하는 연산 처리 기술중 하나이다.

===== 상세설명 =====
==== 특징 ====

스칼라 구조에서 단순히 생각했을 때, CPU는 한 클럭에 하나씩의 명령어를 처리하게 되어있다. 이를 개선해서 동시, 혹은 한 사이클 미만으로 둘 이상의 명령어를 처리하는 방식으로 [[용어:슈퍼스칼라]] 등의 방식이 나왔으나, 이는 파이프라인을 나누어 휴지 상태의 하드웨어를 활용하도록 하는 방식을 사용한다. 이처럼 병렬연산 구조는 겹치지 않는 명령어를 병렬로 동시 진행함으로서 프로세서의 내부에서 작동을 대기하며 휴지 상태로 있는 파트를 줄임으로서 작업효율을 높여 연산 속도를 향상시키는 것에 목적이 있다.

VLIW는 [[용어:ILP|ILP(Instruction Level Parallelism)]]를 최대한 활용해서 병렬 연산을 진행하며, 이를 하나의 긴 명령어 형식 내에 동시에 실행될 수 있는 명령어(연산 코드 및 오퍼랜드)들을 여러 개 포함시킴으로써 각명령어 단위를 인출해 실행할 때 마다 여러 연산이 동시에 실행되도록 하는 방식이다. 명령어 코드는 길지만 하나로 취급되기 때문에 인출과 해독은 하나의 회로에 의해 이루어지고, 각 연산의 실행 사이클만 여러 개의 유니트(ALU를 비롯한 Function unit)들로 나누어져 동시에 처리되게 된다. 

이 방식을 사용하는 프로세서는 여러 개의 기능 유니트들을 가지고 있으며, 이들을 효율적으로 이용할 수 있도록 컴파일시 컴파일러가 서로 다른 유니트를 사용하는 명령어들을 찾아서 하나의 명령어 단어 내에 재배열 해준다. 때문에 하나의 명령어 워드(묶음)에 포함시킬 수 있는 연산(Instruction)을 얼마나 찾아내 최적화 시킬 수 있느냐가 효율의 관건이 된다. 

VLIW는 컴파일러 단에서 명령어의 배치가 이루어지는 방식이기 때문에, 슈퍼스칼라 등의 다른 병렬연산을 위한 방식과 달리 하드웨어 단에서 명령어 스케줄링을 하지 않는다. 때문에 회로를 단순하게 개발하는 것이 가능해지며, 프로세서에서 해당 분야를 처리하지 않아도 되므로 회로 활용 효율이 상승한다. 또한 지정된 하드웨어 내에서 컴파일 시 하드웨어의 잔여부분을 최대한 추적해서 명령어 워드를 만들기 때문에 휴지 상태로 전력을 소모하는 잉여 회로가 감소하게 되어 회로 전체적 활용도가 높아지게 된다. 때문에 VLIW 구조의 프로세서는 대체적으로 프로세서 크기가 상대적으로 작으며, 작동시 잉여 유니트가 거의 없는 것이 특색이다.

그러나 반대로 이야기하면 컴파일러가 VLIW기반의 프로세서를 확실하게 뒷받침해줄 수 있어야 한다는 의미이기 때문에, 그만큼 컴파일러 제작에 사활이 걸린다는 문제가 발생한다. 컴파일러의 성능이 저하되는 것은 즉각 프로세서의 성능 저하로 이뤄질 수 있다는 이야기. 복잡한 연산(예를 들면 고속 푸리에 변환 등)을 한번에 처리하지 못하게 되면 그만큼 다른 연산의 지연으로 이어질 수 있기 때문에 문제가 된다. 이러한 문제 때문에 가변 명령어 길이를 지원하는 VLIW 프로세서도 존재한다. 또한 미리 컴파일을 통해서 명령어 워드를 생성해두는 형태이기 때문에 연산 시에 발생하게 되는 분기 예측이나 캐쉬 미스 등의 상태에 대해서 취약한 점을 가질 수 밖에 없는 구조이며, 때문에 범용 프로그래밍 보다는 이미 흐름이 확실하게 정해진 일방향의 프로그램에서 그 성능이 높게 측정된다.

또 하나의 문제로, VLIW는 여러 명령어를 묶어놓는 구조로 되어있으며, 여기서 스케줄링 또한 모두 고정되기 때문에 VLIW에서 운용되도록 만들어진 바이너리는 하드웨어적인 구성차이에 민감하여 호환성이 떨어진다. (스케줄링을 실시간 관리할 경우 하드웨어의 차이에 따라 CPU에서 명령 처리 순서를 수정할 수 있지만 VLIW는 연산 순서조차 고정되어있어 그것이 불가능하다)


==== 역사 ====
=== 탄생 ===
VLIW에 적용된 개념은 1946년 앨런 터링(Alan Turing)이 만든 병렬 컴퓨팅(parallel computing) 연구와 모리스 윌크스(Maurice Wilkes)가 1951년 세운 마이크로프로그래밍 기술에 기반한다. 마이크로프로그래밍 기법으로 프로그램된 CPU는 매크로명령어(macroinstruction)에 의해서 프로그램의 명령어가 구성되며, 각 매크로명령어는 디코딩되어 CPU의 롬에 담긴 마이크로명령어로 번역되어 프로그램을 실행, 제어한다. 매크로명령어에 의해 실행된 마이크로 명령어는 다양한 신호 다발을 동시 혹은 1클럭 미만으로 처리할 수 있었는데, 이를 수행하는 프로그래밍 방식을 **수평적 마이크로프로그래밍(horizontal microprogramming)**이라고 부른다. 이 방식은 프로세서의 성능을 향상시키는 기술로서 각광을 받다가 IBM에서 [[하드:IBM 시스템-360]] 시리즈에 채용된 이후 광범위하게 사용되게 된다.

이러한 장점에도 불구하고 당시의 마이크로프로그래밍 기법은 자동으로 처리되는 방식이 아니라 스케줄링을 직접 계산한 사람에 의해서 수작업으로 프로그래밍이 이루어졌다. 본격적인 VLIW 개념이 만들어진 것은 1980년 초, 중반에 조셉 피셔(Joseph Fisher)에 의해서였다. 1979년 조셉 피셔는 예일대에 재학하면서 PUMA에서 일하고 있었는데, 이곳에서 CDC-6600 에뮬레이터를 연구하고 있었다. 이 때 64bit 길이의 마이크로프로그래밍을 작성하면서 긴 명령어를 통해 여러 효율적으로 마이크로코드를 묶는 형태에 대해서 연구를 해나가게 된다. 이 연구는 스케줄링 추적(trace scheduling)으로 불리우는데, 현재의 VLIW의 근간이 되는 컴파일러를 통해 선스케줄링(Prescheduling)을 만들어 [[용어:ILP|ILP(instruction-level parallelism)]]를 효율적으로 사용할 수 있는 방법을 발표하게 된다. 즉 이전 세대에 일일이 수작업으로 프로그래밍 해야 했던 부분을 일반적인 프로그램 언어를 수평적 마이크로코드로 타켓 컴파일을 할 수 있는 컴파일러를 개발함으로서 자동으로 처리할 수 있게 만든 것이다. 

이 논문으로 피셔는 박사학위를 취득했으며, 이 연구의 결과로 그는 ELI-512 프로세서의 디자인과 해당 시스템에서 사용되는 **스케줄링 추적 컴파일러**를 개발하게 된다. 이 컴파일러의 이름은 예일대의 마스코트인 불독을 따서 '불독 컴파일러'라고 명명되었다.

=== 멀티플로우와 각종시도 ===

이러한 흐름을 타고 1984년에는 VLIW 기반의 소형 슈퍼컴퓨터가 개발되게 되는데, 피셔와 예일대가 협력해서 개발한 [[하드:Multiflow]]가 바로 그것이다. 1987년 처음으로 작동을 개시한 멀티플로우는 28개의 병렬 연산을 동시에 진행할 수 있었다. 그러나 안타깝게도 멀티플로우는 기기 성능과 별개로 상업적으로는 고려하기 애매한 장비였다. 단순화를 시키는 것이 목적이 되어야 할 VLIW 구조의 장비가 기실 더 복잡한 다수의 장비를 묶어서 시스템을 구축하는 형태로 완성되었기 때문이었다. 또한 아직 무르익지 못한 기술적인 문제 때문에 이후 VLIW를 중심으로 하는 단일CPU 시장은 쇠퇴하게 된다. 단 이 때 완성된 VLIW의 개념과 컴파일러의 구조 등에 대해서는 대부분이 공개됨으로서 후대에 개발되는 CPU, GPU, DSP 등에 도입되어 폭넓은 활용 범위를 보여주게 되는 계기를 열게 된다.

멀티플로우와 같은 해에 Cydrome 사에서는 [[용어:ECL|ECL(Emitter-coupled logic)]] 구조를 도입한 VLIW 구조의 프로세서를 생산했으나, 큰 반향을 일으키지는 못했다. 회사가 문을 닫고나서 Cydrome 사의 창업자인 밥 라우(Bob Rau)와 VLIW 추적 컴파일러의 개발자 조쉬 피셔는 비슷한 시기에 [[회사:HP]]에 합류했고, 이 두사람은 HP에서 컴퓨터 구조를 연구하며 해당 기술을 지속적으로 발전, 융화를 시도했다. 

VLIW 구조 기반의 프로세서가 제대로 빛을 보게 된 것은 전혀 뜻밖에도 구 소련(현 러시아)에서 였다. [[회사:MCST]]에서 개발된 [[하드:옐부르스 프로세서]]시리즈 중 하나인 Elbrus 3부터 VLIW 기반의 구조로 된 프로세서를 구축하기 시작했다. 그러나 냉전시대였기 때문에 이 기술은 서구에 제대로 공개되지 않았기에 이에 대한 평가는 훨씬 뒤로 미뤄지게 된다. (자세한 사항은 [[하드:옐부르스 프로세서]]

비슷한 시기 다양한 개발사들이 VLIW 구조를 연구했으나, 여러 문제로 인해 범용 프로세서로서는 그다지 선호되지 못했으나 미디어 처리용 프로세서로서는 큰 걸음을 내딛기 시작했다. 1987년 [[회사:NXP|필립스(현 NXP)]]의 [[하드:TriMedia]]는 VLIW를 도입한 [[용어:DSP]]로서 효율적이라는 평을 받으며 성공을 거두었고, 뒤이어 [[회사:텍사스 인스트루먼트]]의 [[하드:TI TMS320#C6000 시리즈]]가 선보이면서 이 분야의 활용성이 재평가를 받기 시작했다.

1989년 [[회사:인텔]]은 자사의 첫 64bit 프로세서인 [[하드:인텔 i860]]을 선보였다. 이 프로세서는 단일 칩으로 구현된 최초의 VLIW 프로세서로, [[용어:RISC]]와 VLIW 모드를 모두 작동할 수 있었다. 그러나 이론상 속도의 반에도 미치지 못하는 처절할 정도의 느린 퍼포먼스로 혹평만 받아야 했다. 이는 위에서 설명했듯 복잡한 명령어를 컴파일하는 효율이 나빠 곧바로 성능 하락으로 이어진 것이었다. (그러나 인텔은 i860에서 쌓은 기술을 기반으로 [[용어:SIMD]] 방식으로 고속 명령어 처리를 위한 기술을 개발하는데 성공하니, 이것이 바로 [[용어:MMX]]였다. 이 기술은 개량되어 [[용어:SSE]] 명령어로 발전했으며, 현재까지도 꾸준히 이용되고 있다.)

=== 1990년대 ===

1990년에는 HP에서도 VLIW 기술이 대거 사용된 프로세서 제품군이 선보이게 된다. 바로 [[하드:PA-RISC 프로세서]]이다. HP는 개발중이던 PA-RISC 프로세서에서 복잡한 회로의 상당부분을 제거하고 컴파일러로 이를 대체처리할 수 있도록 변경했으며, 이는 CPU의 다이 크기 감소와 수율 향상, 비용 감소로 이어지는 강점을 낳는데 성공했다.(단 PA-RISC는 VLIW 기반 범용 프로세서가 아니라 RISC 프로세서에 VLIW기능을 접목시킨 것)

SPARC

EPIC프로세서

러시아의 E2K 프로세서를 개량한 [[용어:크루소]] 프로세서가 나오면서였다. 그러나 크루소 프로세서는 x86 프로세서들과 경쟁을 하면서 효율보다는 속도 면에서 뒤쳐지는 모습을 보여주었고, 그 문제로 인해 시장에서 실패하여 다시 시장에서 물러나는 결과를 가져오게 되었다.

[[:추가바람]][[:수정바람]]

{{tag>용어 기술용어 IT용어 CPU 회로 병렬연산}}